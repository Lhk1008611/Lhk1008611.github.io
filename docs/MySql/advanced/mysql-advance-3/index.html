<!doctype html>
<html lang="zh" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-MySql/advanced/mysql-advance-3">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.2.0">
<title data-rh="true">MySQL 高级第三篇 | HankLay 的个人主页</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://lhk1008611.github.io/docs/MySql/advanced/mysql-advance-3"><meta data-rh="true" name="docusaurus_locale" content="zh"><meta data-rh="true" name="docsearch:language" content="zh"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="MySQL 高级第三篇 | HankLay 的个人主页"><meta data-rh="true" name="description" content="索引优化与查询优化"><meta data-rh="true" property="og:description" content="索引优化与查询优化"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://lhk1008611.github.io/docs/MySql/advanced/mysql-advance-3"><link data-rh="true" rel="alternate" href="https://lhk1008611.github.io/docs/MySql/advanced/mysql-advance-3" hreflang="zh"><link data-rh="true" rel="alternate" href="https://lhk1008611.github.io/docs/MySql/advanced/mysql-advance-3" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.db39acd3.css">
<link rel="preload" href="/assets/js/runtime~main.4e6c1dd0.js" as="script">
<link rel="preload" href="/assets/js/main.31e09b09.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/favicon.ico" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/favicon.ico" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">首页</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/intro">文档</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/Lhk1008611" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">个人简历</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/java">Java</a><button aria-label="打开/收起侧边栏菜单「Java」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/mq">MQ</a><button aria-label="打开/收起侧边栏菜单「MQ」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/docs/category/mysql">MySQL</a><button aria-label="打开/收起侧边栏菜单「MySQL」" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" tabindex="0" href="/docs/category/mysql-基础">MySQL 基础</a><button aria-label="打开/收起侧边栏菜单「MySQL 基础」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" tabindex="0" href="/docs/category/mysql-高级">MySQL 高级</a><button aria-label="打开/收起侧边栏菜单「MySQL 高级」" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/MySql/advanced/mysql-advance-1">MySQL 高级第一篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/MySql/advanced/mysql-advance-2">MySQL 高级第二篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/MySql/advanced/mysql-advance-3">MySQL 高级第三篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/MySql/advanced/mysql-advance-4">MySQL 高级第四篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/MySql/advanced/mysql-advance-5">MySQL 高级第五篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/MySql/advanced/mysql-advance-6">MySQL 高级第六篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/MySql/advanced/mysql-advance-7">MySQL 高级第七篇</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/MySql/advanced/mysql-advance-8">MySQL 高级第八篇</a></li></ul></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/linux">Linux</a><button aria-label="打开/收起侧边栏菜单「Linux」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/ssm">SSM</a><button aria-label="打开/收起侧边栏菜单「SSM」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/redis">Redis</a><button aria-label="打开/收起侧边栏菜单「Redis」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/dubbo">Dubbo</a><button aria-label="打开/收起侧边栏菜单「Dubbo」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/docker">Docker</a><button aria-label="打开/收起侧边栏菜单「Docker」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/spring-cloud">Spring Cloud</a><button aria-label="打开/收起侧边栏菜单「Spring Cloud」" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/cloud-native">Cloud Native</a><button aria-label="打开/收起侧边栏菜单「Cloud Native」" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/mysql"><span itemprop="name">MySQL</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/mysql-高级"><span itemprop="name">MySQL 高级</span></a><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">MySQL 高级第三篇</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><h1>MySQL 高级第三篇</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="索引优化与查询优化">索引优化与查询优化<a class="hash-link" href="#索引优化与查询优化" title="标题的直接链接">​</a></h2><p>进行数据库调优的维度：</p><ul><li>索引失效。没有充分利用到索引 —— 索引建立</li><li>关联查询太多JOIN (设计缺陷或不得已的需求) —— SQL优化</li><li>服务器调优及各个参数设置(缓冲、线程数等)  —— 调整my.cnγ</li><li>数据过多 —— 分库分表</li></ul><blockquote><p>虽然SQL查询优化的技术有很多，但是大方向上完全可以分成<code>物理查询优化</code>和<code>逻辑查询优化</code>两大块。</p><ul><li>物理查询优化是<code>通过索引和表连接方式等技术来进行优化</code>，这里<code>重点需要掌握索引|的使用</code>。</li><li>逻辑查询优化就是<code>通过SQL等价变换提升查询效率</code>，直白一点就是说，换一种查询写法执行效率可能更高。</li></ul><p>其实，用不用索引，最终都是优化器说了算。优化器是基于基于<code>cost开销(CostBaseOptimizer)</code>的优化器。它不是基于<code>规则(Rule-Basedeptimizer)</code>，也不是基于语义。怎么样开销小就怎么来，另外, <code>SQL语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系</code>。</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1索引优化一般性建议">1.索引优化一般性建议<a class="hash-link" href="#1索引优化一般性建议" title="标题的直接链接">​</a></h3><blockquote><ul><li>对于单列索引，尽量选择针对当前query过滤性更好的索引</li><li>在选择组合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li><li>在选择组合索引的时候，尽量选择能够包含当前query中的where子句中更多字段的索引。</li><li>在选择组合索弓|的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引|次序的最后面。</li></ul><p><code>总之，书写SQL语句时，尽量避免造成索引失效的情况。</code></p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2-连接查询的优化join语句原理">2. 连接查询的优化——join语句原理<a class="hash-link" href="#2-连接查询的优化join语句原理" title="标题的直接链接">​</a></h3><ul><li>内连接<blockquote><ul><li>对于内连接来说，查询优化器可以决定谁作为驱动表，谁作为被驱动表出现的。</li><li>对于内连接来说，如果表的连接条件中只有一个字段有索引，<code>则有索引的字段所在的表会被作为被驱动表出现</code>。</li><li>对于内连接来说，在两个表的连接条件都存在索引的情况下，会选择小表作为驱动表。<code>“小表驱动大表”</code></li></ul></blockquote></li></ul><ul><li>join原理<blockquote><p>join方式连接多个表，<code>本质就是各个表之间数据的循环匹配</code>。MySQL5.5 版本之前，MySQL只支持一种表间关联方式，就是<code>成套循环(Nested Loop Join)</code>。如果关联表的数据量很大，则join关联的执行时间会非常长。在MySQL5.5以后的版本中，MySQL通过引入<code>BNLJ算法(块嵌套循环)</code>来<code>优化嵌套执行</code>。</p></blockquote></li></ul><ul><li><p>成套循环(Nested Loop Join)的相关算法</p><blockquote><ul><li>SNLJ(Simple Nested Loop Join) 算法——简单的成套循环算法</li><li>INLJ(Index Nested Loop Join)算法——<code>基于索引</code>的成套循环算法</li><li>BNLJ(Block Nested Loop Join)算法——<code>基于块</code>的成套循环算法</li></ul><p>后面两种算法都是对第一个算法进行优化的优化算法`</p><ol><li><code>效率比较：INLJ&gt;BNLJ&gt;SNLJ</code></li><li>永远用<code>小结果集</code>驱动<code>大结果集</code>(其本质就是减少外层循环的数据数量) (<code>小的度量单位指的是表行数*每行大小</code>)</li><li>为被驱动表匹配的条件增加索引减少内层表的循环匹配次数</li><li>增大join_buffer_size的大小(一次缓存的数据越多，那么内层表的扫表次数就越少)</li><li>减少驱动表不必要的字段查询(字段越少，join buffer所缓存的数据就越多)</li></ol></blockquote><div class="language-sql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-sql codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">#查看‘block_nested_loop’的状态，默认是开启的</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">SHOW</span><span class="token plain"> VARIABLES </span><span class="token operator" style="color:#393A34">LIKE</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;%optimizer_switch%&#x27;</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">#查看join_buffer的大小,默认256k</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">SHOW</span><span class="token plain"> VARIABLES </span><span class="token operator" style="color:#393A34">LIKE</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;%join_buffer%&#x27;</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></li><li><p>mysql8新特性——hash join</p><blockquote><p>从MySQL的8.0.20版本开始将废弃BNLJ,因为从MySQL8.0.18版本开始就加入 了hash join默认都会使用hash join</p><ul><li>Nested Loop:
对于<code>被连接的数据子集较小的情况</code>,Nested Loop是个较好的选择。</li><li><code>Hash Join是做大数据集连接时的常用方式</code>，优化器使用两个表中较小(相对较小)的表利用Join Key在内存中建立散列表，然后扫描较大的表并探测散列表，找出与Hash表匹配的行。<ul><li>这种方式适用于较小的表完全可以放于内存中的情况，这样总成本就是访问两个表的成本之和。</li><li>在表很大的情况下并不能完全放入内存，这时优化器会将它分割成若干不同的分区，不能放入内存的部分就把该分区写入磁盘的临时段，此时要求有较大的临时段从而尽量提高I/0的性能。</li><li>它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。大多数人都说它是Join的重型升降机。<code>Hash Join只能应用于等值连按(如WHERE A.COL1 = B.COL2),这是由Hash的特点决定的。</code></li></ul></li></ul></blockquote></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3子查询优化">3.子查询优化<a class="hash-link" href="#3子查询优化" title="标题的直接链接">​</a></h3><blockquote><p>子查询是MySQL的一项重要的功能，可以帮助我们通过一个SQL语句实现比较复杂的查询。但是，子查询的执 行效率不高。原因:</p><ol><li>执行子查询时，MySQL需要<code>为内层查询语句的查询结果建立个临时表</code> ，然后外层查询语句从临时表中查询记录。查询完毕后，再撤销这些临时表。这样会消耗过多的CPU和I0资源，产生大量的慢查询。</li><li>子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。</li><li>对于返回结果集比较大的子查询，其对查询性能的影响也就越大</li></ol></blockquote><p>在MySQL中，<code>可以使用连接(JOIN) 查询来替代子查询</code>。连接查询不需要建立临时表，其速度比子查询要快，如果查询中使用索引的话，性能就会更好。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="4排序优化">4.排序优化<a class="hash-link" href="#4排序优化" title="标题的直接链接">​</a></h3><p>问题：在WHERE条件字段上加索引，但是为什么在ORDER BY字段上还要加索引呢?</p><blockquote><p>在MySQL中，支持两种排序方式，分别是FileSort 和Index排序。</p><ul><li><code>Index 排序</code>中，索引可以保证数据的有序性,不需要再进行排序，效率更高。 </li><li><code>FileSort 排序</code>则一般在内存中进行排序，占用CPU较多。如果待排结果较大，会产生临时文件I/0到磁盘进行排序的情况，效率较低。</li></ul></blockquote><blockquote><ol><li>SQL 中，可以在WHERE子句和ORDER BY子句中使用索引，<code>目的是在WHERE子句中避免全表扫描</code>，<code>在ORDER BY子句避化使用FileSort排序</code>。当然，某些情况下全表扫描，或者FileSort排序不一定比索引慢。但总的来说，我们还是要避免，以提高直询效率,</li><li><code>尽量使用Index完成ORDER BY排序</code>。如果WHERE和ORDER BY后面是相同的列就使用单索引列;如果不同就使用联合索引。
3.无法使用Index时，需要对FileSort方式进行调优。</li></ol></blockquote><ul><li><p>filesort算法——双路排序和单路排序</p><blockquote><p>排序的字段若如果不在索引列上，则filesort会有两种算法: <code>双路排序</code>和<code>单路排序</code></p><ol><li><code>双路排序(慢)</code></li></ol><ul><li>MySQL 4.1之前足使用双路排序，字面意思就是<code>两次扫描磁盘</code>，最终得到数据， 读取行指针和order by列,对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从磁盘中读取对应的数据输出</li><li>从磁盘取排序字段，在buffer进行排序, 再从磁盘取其他字段。</li></ul><p>取一批数据，要对磁盘进行两次扫描，众所周知, I0是很耗时的，所以在mysql4.1之后， 出现了第二种改进的算法，就是单路排序。</p><ol start="2"><li><code>单路排序（快）</code>
从磁盘读取查询需要的所有列，按照order by列在bbffr对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机I0变成了顺序I0，但是它会使用更多的空间，因为它把每一行都保存在内存中了。</li></ol></blockquote><blockquote><p>但是用单路也有问题。</p><ul><li>在sort<em>buffer中， <code>单路比多路要多占用很多空间</code>，因为单路是把所有字段都取出，所以有可能取出的数据的总大小超出了sort_buffer 的容量，导致每次只能取sort</em> buffer容量大小的数据，进行排序(创建tmp文件.多路合并) , 排完再取sot_bufr容量大小，再排.... 从而多次I/0。单路本来想省一次I/0操作， 却导致了大量的I/0操作，得不偿失。</li></ul><p>对于该问题，</p><ol><li>我们可以提高<code>sort_buffer_size</code>参数进行优化，增加这个参数都会提高这两个算法的效率</li></ol></blockquote><div class="language-sql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-sql codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">show</span><span class="token plain"> variables </span><span class="token operator" style="color:#393A34">like</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;sort_buffer_size&#x27;</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><blockquote><ol start="2"><li>提高参数&#x27;<code>max_length_for_sort_data</code>&#x27; 提高这个参数，会增加用改进算法的概率，但是如果设的太高，数据总容量超出<code>sort_buffer_size</code>的概率就增大，明显症状是高的磁盘I/0活动和低的处理器使用率。如果需要返回的列的总长度大于<code>max_length_for_sort_data</code>,使用双路算法，否则使用单路算法。 1024-8192字节之间调整</li></ol></blockquote><div class="language-sql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-sql codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">show</span><span class="token plain"> variables </span><span class="token operator" style="color:#393A34">like</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;max_length_for_sort_data&#x27;</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><blockquote><ol start="3"><li>Order by时select *是一个大忌。
最好只Query需要的字段。原因:<ul><li>当Query的字段大小总和<code>小于max_length_for_sort_data</code>，而且排序字段不是TEXT|BLOB类型时，会用改进后的算法——单路排序， 否则用老算法——多路排序。</li></ul></li></ol><ul><li>两种算法的数据都有可能超出<code>sort_buffer_size</code>的容量，超出之后，会创建tmp文件进行合并排序，导致多次 I/0，但是用单路排序算法的风险会更大一些，所以要<code>提高sort_buffer_size</code>。</li></ul></blockquote></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5-group-by优化">5. group by优化<a class="hash-link" href="#5-group-by优化" title="标题的直接链接">​</a></h3><blockquote><ul><li>group by使用索引的原则几乎跟order by一致 ，group by即使没有过滤条件用到索引，也可以直接使用索引。 </li><li>group by先排序再分组，遵照索引建的最佳左前缀法则 </li><li>当无法使用索引列，增大<code>max_length_for_sort_data</code>和<code>sort_buffer_size</code>参数的设置 </li><li>where效率高于having, 能写在where限定的条件就不要写在having中了 </li><li>减少使用order by，和业务沟通能不排序就不排序，或将排序放到程序端去做。order by、group by、distinct 这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的</li><li>包含了order by、group by、distinct这些查询的语句， where条件过滤出来的结果案请保持在1000行以内，否则SQL会很慢。</li></ul></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="6分页查询limit优化">6.分页查询（limit）优化<a class="hash-link" href="#6分页查询limit优化" title="标题的直接链接">​</a></h3><blockquote><p>优化思路一
在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容，这种优化方式更适用于主键不是自增的情况。
优化思路二
该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询。</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="7覆盖索引">7.覆盖索引<a class="hash-link" href="#7覆盖索引" title="标题的直接链接">​</a></h3><blockquote><p><code>覆盖索引</code>：
索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据;当能通过读取索引就可以得到想要的效据，那就不需要读取行了（<code>不需要进行回表操作</code>）。<code>一个索引包含了满足查询结果的数据就叫做覆盖索引</code>。</p></blockquote><ul><li>覆盖索引的利弊<blockquote><p>优点：</p><ol><li>避免Innodb表进行索引的二次查询(回表)
Innodb是以聚集索引的顺序来存储的，对于Innodb来说， 二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据，在查找到相应的键值后，还需通过主键进行二次查询才能获取我们真实所需要的数据。
在覆盖索引中，二级索引的键值中可以获取所要的数据，避免了对主键的二次查询 ，减少了I0操作，提升了查询效率。</li><li>可以把随机I0变成顺序I0加快查询效率
由于覆盖索引是按键值的顺序存储的，对于I0密集型的范围查找来说，对比随机从磁盘读取每一行的数据I0要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的I0转变成索引查找的顺序I0。
由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</li></ol><p>弊端:</p><ul><li>索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索弓时就需要权衡考虑了。这是业务DBA，或者称为业务数据架构师的工作。</li></ul></blockquote></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="8索引条件下推icp">8.索引条件下推（ICP）<a class="hash-link" href="#8索引条件下推icp" title="标题的直接链接">​</a></h3><blockquote><p>索引条件下推：
在查询的时候使用到了联合索引的某一个字段，若查询条件中还有其他字段也属于该联合索引，且该字段也并未使用到索引，则mysql优化器会对该索引进行索引下推，对该字段进行筛选后再进行回表操作。
<code>这样的好处是可以减少回表操作，减少随机IO的次数。</code></p></blockquote><ul><li><p>开启和关闭索引条件下推</p><div class="language-sql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-sql codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">#开启索引条件下推（默认开启ICP）</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">SET</span><span class="token plain"> optimize_switch </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;index_condition_pushdown=on&#x27;</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">#关闭索引条件下推</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">SET</span><span class="token plain"> optimize_switch </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&#x27;index_condition_pushdown=off&#x27;</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><blockquote><ul><li>当使用索引条件下推时，EXPLAIN语句输出结果中Extra列内容显示为<code>Using index condition</code></li></ul></blockquote></li><li><p>使用ICP的条件</p><blockquote><ol><li>如果表访问的类型为range、ref、eq<em>ref和ref</em> or_null可以使用ICP</li><li>ICP可以用于InnoDB和MyISAM表， 包括分区表InnoDB和MyISAM表</li><li>对于InnoDB表，ICP仅用于二级索引 。ICP 的目标是减少全行读取次数，从而减少I/0操作。</li><li>当SQL使用覆盖索引时，不支持ICP。因为这种情况下使用ICP不会减少I/0. .</li><li>相关子查询的条件不能使用ICP</li></ol></blockquote></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="9其他查询优化策略">9.其他查询优化策略<a class="hash-link" href="#9其他查询优化策略" title="标题的直接链接">​</a></h3><ul><li><p>9.1 EXISTS 和 IN 的区分，何时使用EXISTS，何时使用IN？</p><blockquote><p>对于何时使用EXISTS和IN，索引是个前提，其实选择与否还是要看表的大小。你可以将选择的标准理解为<code>小表驱动大表</code>。在这种方式下效率是最高的。</p></blockquote><p>  例：</p><div class="language-sql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-sql codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">select</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">from</span><span class="token plain"> A </span><span class="token keyword" style="color:#00009f">where</span><span class="token plain"> cc </span><span class="token operator" style="color:#393A34">in</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">select</span><span class="token plain"> cc </span><span class="token keyword" style="color:#00009f">from</span><span class="token plain"> B</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当B表比A表小时，使用IN，因为其实现逻辑类似于</p><div class="language-sql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-sql codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">for</span><span class="token plain"> i </span><span class="token operator" style="color:#393A34">in</span><span class="token plain"> B</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">for</span><span class="token plain"> j </span><span class="token operator" style="color:#393A34">in</span><span class="token plain"> A</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> j</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">cc</span><span class="token operator" style="color:#393A34">=</span><span class="token operator" style="color:#393A34">=</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">cc </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>而当B表比A表大时，则使用EXISTS</p><div class="language-sql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-sql codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">select</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">from</span><span class="token plain"> A </span><span class="token keyword" style="color:#00009f">where</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">exists</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">select</span><span class="token plain"> cc </span><span class="token keyword" style="color:#00009f">from</span><span class="token plain"> B </span><span class="token keyword" style="color:#00009f">where</span><span class="token plain"> B</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">cc</span><span class="token operator" style="color:#393A34">=</span><span class="token plain">A</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">cc</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>实现逻辑如下：</p><div class="language-sql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-sql codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">for</span><span class="token plain"> i </span><span class="token operator" style="color:#393A34">in</span><span class="token plain"> A</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">for</span><span class="token plain"> j </span><span class="token operator" style="color:#393A34">in</span><span class="token plain"> B</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> j</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">cc</span><span class="token operator" style="color:#393A34">=</span><span class="token operator" style="color:#393A34">=</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">cc </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><span class="token punctuation" style="color:#393A34">.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><blockquote><p><code>根据其实现逻辑，按小表驱动大表的规则进行选择即可</code>。</p></blockquote></li></ul><ul><li><p>9.2 COUNT( * )与COUNT(具体字段)效率</p><blockquote><p>在MySQL中统计数据表的行数，可以使用三种方式: <code>SELECT COUNT(*)</code>、<code>SELECT COUNT(1)</code>和<code>SELECT COUNT(具体字段)</code>，使用这三者之间的查询效率是怎样的?</p></blockquote><blockquote><p>对于该问题有一个前提:需要保证这三个语句执行的结果都为统计表的所有行数，如果你要统计的是某个字段的非空数据行数，则另当别论，毕竟比较执行效率的前提是结果一样才可以。</p><ol><li>COUNT( <em> )和COUNT(1)都是<code>对所有结果进行COUNT</code>，`COUNT(</em>)<code>和</code>COUNT(1)`本质上并没有区别(二者执行时间可能略有差别，不过你还是可以把它俩的执行效率看成是相等的)。如果有WHERE子句，则是对所有符合筛选条件的数据行进行统计;如果没有WHERE子句，则是对数据表的数据行数进行统计。</li><li>如果用的是<code>MyISAM</code>存储引擎，统计数据表的行数只需要<code>0(1)的复杂度</code>，这是因为每张MyISAM的数据表都有一个meta信息存储了<code>row_count</code>值，而一致性则由<code>表级锁</code>来保证。
如果是<code>InnoDB</code>存储引擎，因为InnoDB支持事务，采用<code>行级锁</code>和<code>MVCC机制</code>，所以无法像MylSAM一样，维护一个row_count变量，因此需要采用扫描全表，是<code>0(n)的复杂度</code>，进行循环＋计数的方式来完成统计。</li><li>在<code>InnoDB</code>引擎中，如果采用<code>COUNT(具体字段)</code>来统计数据行数，要<code>尽量采用二级索引</code>。 因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引(非聚簇索引)。
对于<code>COUNT(*)</code>和<code>COUNT(1)</code>来说，它们不需要查找具体的行，只是统计行数，<code>系统会自动采用占用空间更小的二级索引来进行统计。如果有多个二级索引，会使用key_len小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。</code></li></ol></blockquote></li></ul><ul><li><p>9.3 关于 SELECT ( * )</p><blockquote><p>在表查询中，建议明确字段，不要使用*作为查询的字段列表，<code>推荐使用SELECT&lt;字段列表&gt;查询</code>。
原因:</p><ol><li>MysQL在解析的过程中，会通过查询数据字典将&quot;<code>*</code>&quot;按序转换成所有列名，这会大大的耗费资源和时间。</li><li><code>无法使用覆盖索引</code></li></ol></blockquote></li><li><p>9.4 <code>LIMIT 1</code>对优化的影响</p><blockquote><p><code>LIMIT 1</code>针对的是会扫描全表的SQL语句，如果你可以确定结果集只有一条，那么加上<code>LIMIT 1</code>的时候，当找到一条结果的时候就不会继续扫描了,这样会加快查询速度。
但是如果数据表已经对字段建立了唯一索引，那么可以直接通过唯一索引进行查询到某一条结果集，因为使用索引就不会全表扫描了，所以就不需要加上LIMIT 1了。</p></blockquote></li><li><p>9.5 多使用 COMMIT</p><blockquote><p><code>只要有可能，在程序中尽量多使用COMMIT，这样程序的性能得到提高，需求也会因为COMMIT所释放的资源而减少</code>。
COMMIT 所释放的资源: </p><ul><li>回滚段上用于恢复数据的信息 </li><li>被程序语句获得的锁 </li><li>redo/ undo log buffer中的空间</li><li>管理上述3种资源中的内部花费</li></ul></blockquote></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="10推荐的主键设计">10.推荐的主键设计<a class="hash-link" href="#10推荐的主键设计" title="标题的直接链接">​</a></h3><blockquote><p><code>非核心业务</code>:对应表的<code>主键自增ID</code>,如告警、日志、监控等信息。
<code>核心业务</code>:<code>主键设计至少应该是全局唯一且是单调递增</code>。全局唯一保证在各系统之间都是唯一的， 单调递增是希望插入时不影响数据库性能。
这里推荐最简单的一种主键设计: <code>改造后的UUID</code></p></blockquote><ul><li><p>原始的 UUID：</p><blockquote><p>特点: 全局唯一,占用36字节，数据无序，插入性能差。</p></blockquote><p>  <img loading="lazy" alt="original_uuid" src="/assets/images/original_uuid-a21a04d1fda1105e2dad671ffa64d32f.png" width="1170" height="361" class="img_ev3q"></p></li><li><p>改造UUID</p><blockquote><p><code>若将时间高低位互换，则时间就是单调递增的了</code>,UUID也就变得单调递增了。MySQL 8.0可以更换时间低位和时间高位的存储方式，这样UUID就是有序的UUID了。
MySQL8.0还解决了UUID存在的空间占用的问题，除去了UUID字符串中无意义的&quot;-&quot;字符串，<code>并且将UUID字符串用二进制类型保存，这样存储空间降低为了16字节</code>。
可以通MySQL8.0提供的<code>uuid_to_bin</code>函数实现上述功能，同样的，MySQL也提供了<code>bin_to_uuid</code>函数进行转化: .</p></blockquote><div class="language-sql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-sql codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">SET</span><span class="token plain"> </span><span class="token variable" style="color:#36acaa">@uuid</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> UUID</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">#uuid_to_bin(@uuid)将原始UUID转换成二进制存储的UUID</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic">#uuid_to_bin(@uuid,TRUE)将高位时间和低位时间位置进行交换</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">SELECT</span><span class="token plain"> </span><span class="token variable" style="color:#36acaa">@uuid</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain">uuid_to_bin</span><span class="token punctuation" style="color:#393A34">(</span><span class="token variable" style="color:#36acaa">@uuid</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain">uuid_to_bin</span><span class="token punctuation" style="color:#393A34">(</span><span class="token variable" style="color:#36acaa">@uuid</span><span class="token punctuation" style="color:#393A34">,</span><span class="token boolean" style="color:#36acaa">TRUE</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>  <img loading="lazy" alt="original_uuid" src="/assets/images/reform_uuid-3fe91780c56359cb86399595b08d1105.png" width="1286" height="222" class="img_ev3q"></p><blockquote><p>通过函数<code>uuid_to_bin(@uuid,true)</code>将UUID转化为有序UUID了。<code>全局唯一 + 单调递增</code>，这不就是我们想要的主键!
在当今的互联网环境中，<code>非常不推荐自增ID作为主键的数据库设计</code>。<code>更推荐类似有序UUID的全局唯一的实现</code>。
另外在真实的业务系统中，主键还可以加入业务和系统属性，如用户的尾号，机房的信息等。这样的主键设计就更为考验架构师的水平了。</p></blockquote></li></ul></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文档分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/MySql/advanced/mysql-advance-2"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">MySQL 高级第二篇</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/MySql/advanced/mysql-advance-4"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">MySQL 高级第四篇</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#索引优化与查询优化" class="table-of-contents__link toc-highlight">索引优化与查询优化</a><ul><li><a href="#1索引优化一般性建议" class="table-of-contents__link toc-highlight">1.索引优化一般性建议</a></li><li><a href="#2-连接查询的优化join语句原理" class="table-of-contents__link toc-highlight">2. 连接查询的优化——join语句原理</a></li><li><a href="#3子查询优化" class="table-of-contents__link toc-highlight">3.子查询优化</a></li><li><a href="#4排序优化" class="table-of-contents__link toc-highlight">4.排序优化</a></li><li><a href="#5-group-by优化" class="table-of-contents__link toc-highlight">5. group by优化</a></li><li><a href="#6分页查询limit优化" class="table-of-contents__link toc-highlight">6.分页查询（limit）优化</a></li><li><a href="#7覆盖索引" class="table-of-contents__link toc-highlight">7.覆盖索引</a></li><li><a href="#8索引条件下推icp" class="table-of-contents__link toc-highlight">8.索引条件下推（ICP）</a></li><li><a href="#9其他查询优化策略" class="table-of-contents__link toc-highlight">9.其他查询优化策略</a></li><li><a href="#10推荐的主键设计" class="table-of-contents__link toc-highlight">10.推荐的主键设计</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 HankLay, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.4e6c1dd0.js"></script>
<script src="/assets/js/main.31e09b09.js"></script>
</body>
</html>